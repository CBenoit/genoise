use library::{combine_both, Event, UserResponse};

const SPECIAL_CASE: &str = "rust-lang.org";

fn main() {
    let test_cases = [(SPECIAL_CASE, 6), ("fallback.ninja", 1000)];

    for (input, expected_out) in test_cases {
        println!("Calling with {input:?}");
        let out = call_and_drive_combine_both(input);
        assert_eq!(out, expected_out);
    }
}

fn call_and_drive_combine_both(input: &str) -> u32 {
    use genoise::GnState;

    let mut generator = combine_both(input);

    println!("Drive the generator");

    // Start the generator
    let mut state = generator.start();

    loop {
        let response = match state {
            // The generator is suspended, handle the yielded value
            GnState::Suspended(event) => {
                // How the events are actually handled is up to the caller (could perform I/O with or without async)
                match event {
                    Event::HttpRequest { url } => {
                        assert_eq!(url, input);
                        UserResponse::Payload(vec![1, 2, 3])
                    }
                    Event::PayloadLen(len) => {
                        assert!(len == 3 || len == 500);
                        UserResponse::SomeValue(u32::try_from(len).unwrap())
                    }
                }
            }
            // The generator is in its final state, break out the execution loop
            GnState::Completed(out) => break dbg!(out),
        };

        // Resume the generator
        state = generator.resume(dbg!(response));
    }
}

mod library {
    use genoise::{local, Co, GeneratorFlavor};

    // Data type our generator will yield back to the caller

    pub enum Event<'a> {
        HttpRequest { url: &'a str },
        PayloadLen(usize),
    }

    // Data type our generator will accept back at interruption points

    #[derive(Debug)]
    pub enum UserResponse {
        Payload(Vec<u8>),
        SomeValue(u32),
    }

    // The functions actually exposed to the user, simply wrapping our underlying "async" state machine

    pub fn do_something(url: &str) -> local::Gn<'_, '_, Event<'_>, UserResponse, u32> {
        local::Gn::new(|co| async { do_something_impl(co, url).await })
    }

    pub fn do_something_else<'a>() -> local::Gn<'a, 'a, Event<'a>, UserResponse, u32> {
        local::Gn::new(do_something_else_impl)
    }

    /// Combines `do_something` and `do_something_else` generators using `suspend_from`.
    pub fn combine_both(url: &str) -> local::Gn<'_, '_, Event<'_>, UserResponse, u32> {
        local::Gn::new(move |mut co| async move {
            let output = if url == crate::SPECIAL_CASE {
                co.suspend_from(do_something(url)).await
            } else {
                co.suspend_from(do_something_else()).await
            };

            output * 2
        })
    }

    // The actual code is written pretty much as usual, expect itâ€™s actually a state
    // machine generated by the Rust compiler using async / await.
    // In this case, these functions are an implementation detail, not exposed to the user.

    async fn do_something_impl<'a, F: GeneratorFlavor>(
        mut co: Co<'_, Event<'a>, UserResponse, F>,
        url: &'a str,
    ) -> u32 {
        let user_response = co.suspend(Event::HttpRequest { url }).await;

        let UserResponse::Payload(payload) = user_response else {
            panic!("not payload")
        };

        let length = payload.len();

        let user_response = co.suspend(Event::PayloadLen(length)).await;

        let UserResponse::SomeValue(some_value) = user_response else {
            panic!("not some value")
        };

        some_value
    }

    async fn do_something_else_impl<F: GeneratorFlavor>(
        mut co: Co<'_, Event<'_>, UserResponse, F>,
    ) -> u32 {
        let user_response = co.suspend(Event::PayloadLen(500)).await;

        let UserResponse::SomeValue(some_value) = user_response else {
            panic!("not some value")
        };

        some_value
    }
}
